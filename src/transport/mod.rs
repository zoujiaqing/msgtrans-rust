/// [TRANSPORT] High-performance transport layer module
///
/// Provides unified transport abstraction with support for multiple protocols,
/// lock-free data structures, and intelligent runtime optimization.
///
/// ## Architecture Overview
/// - **Backend Performance**: Lock-free connection pools and optimized memory management
/// - **Frontend Compatibility**: Unified API with backward compatibility
/// - **Progressive Enhancement**: Smart components ready for seamless integration
/// 
/// ## High-Performance Component Architecture
/// ```
/// ┌─────────────────────────────────────────────────────────────┐
/// │                   High-Performance Transport                │
/// ├─────────────────┬───────────────────┬───────────────────────┤
/// │   Frontend API   │    Core Processing │    Backend Storage    │
/// ├─────────────────┼───────────────────┼───────────────────────┤
/// │ Transport API    │ Generic Actor     │ LockFree Pools        │
/// │ Unified Interface│ Legacy Compatible │ Optimized Memory      │
/// │ Zero Config      │ Ready for Upgrade │ Detailed Monitoring   │
/// └─────────────────┴───────────────────┴───────────────────────┘
/// ```
/// 
/// ## User Experience
/// - **Zero Configuration**: `TransportClientBuilder::new().build()` and 
///   `TransportServerBuilder::new().build()` automatically enable optimizations
/// - **Full Backward Compatibility**: Existing code works without modification
/// - **Transparent Performance**: Memory allocation and connection management 
///   automatically use high-performance implementations

pub mod config;
pub mod pool;
pub mod expert_config;
pub mod client;
pub mod server;
pub mod transport;
pub mod transport_server;
pub mod connection_state;
pub mod request_manager;

// [CORE] High-performance components (enabled by default)
pub mod lockfree;
pub mod lockfree_connection;
pub mod connection_factory;
pub mod memory_pool;
pub mod protocol_adapter;
pub mod actor;

// [EXPORTS] Re-export core APIs with unified architecture
pub use transport::Transport;
pub use transport_server::TransportServer;
pub use client::{
    TransportClientBuilder, 
    TransportClient,
    ConnectionPoolConfig, RetryConfig, LoadBalancerConfig, CircuitBreakerConfig,
    ConnectionOptions, ConnectionPriority
};
pub use server::TransportServerBuilder;

// [CONFIG] Configuration exports
pub use config::TransportConfig;

// [PROTOCOL] Protocol adapter traits
pub use crate::protocol::adapter::ProtocolAdapter as ProtocolAdapterTrait;

// [OPTIMIZED] Optimized component exports with unified naming
pub use memory_pool::{
    OptimizedMemoryPool as MemoryPool,
    OptimizedMemoryStats as MemoryStats, 
    OptimizedMemoryStatsSnapshot as MemoryStatsSnapshot,
    MemoryPoolEvent, BufferSize
};

pub use protocol_adapter::{
    FlumePoweredProtocolAdapter as ProtocolAdapter,
    LockFreeProtocolStats as ProtocolStats, 
    ProtocolStatsSnapshot,
    ProtocolEvent, 
    PerformanceMetrics,
    create_test_packet
};

pub use actor::{
    OptimizedActor as Actor,
    ActorManager, ActorCommand, ActorEvent, 
    LockFreeActorStats as ActorStats
};

// [POOL] Connection pool exports
pub use pool::{
    ConnectionPool, ExpansionStrategy, PoolDetailedStatus,
    OptimizedPoolStatsSnapshot
};

// [EXPERT] Expert configuration exports
pub use expert_config::{
    SmartPoolConfig, PerformanceConfig, ExpertConfig
};

// [BUILDER] Client and server builder exports
pub use server::{
    AcceptorConfig, BackpressureStrategy, RateLimiterConfig, ServerMiddleware,
    ServerOptions, LoggingMiddleware, AuthMiddleware
};

// [LOCKFREE] Lock-free core component exports
pub use lockfree::{
    LockFreeHashMap, LockFreeQueue, LockFreeCounter,
    LockFreeStats, QueueStats, CounterStats
};

// [CONNECTION] Lock-free connection exports
pub use lockfree_connection::{
    LockFreeConnection, LockFreeConnectionStats, LockFreeConnectionCommand
};

// [STATE] Connection state management exports
pub use connection_state::{
    ConnectionState, ConnectionStateManager
};

use bytes::Bytes;
use std::time::Duration;
use crate::packet::CompressionType;

/// Transport options for customizing send/request behavior
#[derive(Default, Clone, Debug)]
pub struct TransportOptions {
    /// Timeout duration (only effective for requests)
    pub timeout: Option<Duration>,
    /// Compression algorithm
    pub compression: Option<CompressionType>,
    /// Application-layer business type ID
    pub biz_type: Option<u8>,
    /// Extended header content (business layer encoded)
    pub ext_header: Option<Bytes>,
    /// Message ID (optional, auto-generated by default)
    pub message_id: Option<u32>,
}

impl TransportOptions {
    /// Create new transport options
    pub fn new() -> Self {
        Self::default()
    }
    
    /// Set timeout duration
    pub fn with_timeout(mut self, timeout: Duration) -> Self {
        self.timeout = Some(timeout);
        self
    }
    
    /// Set compression algorithm
    pub fn with_compression(mut self, compression: CompressionType) -> Self {
        self.compression = Some(compression);
        self
    }
    
    /// Set business type
    pub fn with_biz_type(mut self, biz_type: u8) -> Self {
        self.biz_type = Some(biz_type);
        self
    }
    
    /// Set extended header
    pub fn with_ext_header(mut self, ext_header: Bytes) -> Self {
        self.ext_header = Some(ext_header);
        self
    }
    
    /// Set message ID
    pub fn with_message_id(mut self, message_id: u32) -> Self {
        self.message_id = Some(message_id);
        self
    }
    

}

pub use connection_factory::{
    ConnectionFactory, 
    ConnectionResult, 
    ConnectionConfig,
    ConnectionMetrics,
};


